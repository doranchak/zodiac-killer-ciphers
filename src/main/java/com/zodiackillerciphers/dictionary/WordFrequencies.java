package com.zodiackillerciphers.dictionary;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

import com.zodiackillerciphers.ciphers.Ciphers;
import com.zodiackillerciphers.ciphers.Z340Solution;
import com.zodiackillerciphers.ciphers.algorithms.ResultBean;
import com.zodiackillerciphers.io.FileUtil;
import com.zodiackillerciphers.lucene.Stats;

import org.apache.commons.lang.StringUtils;

/** load word frequencies from various corpora files.  */
/** todo: "didn't" seems underrepresented in the corpora */
public class WordFrequencies {
	public static Boolean SCRUB = false;
	
	/** maps uppercased word to number of occurrences in corpora */
	public static Map<String, Integer> map;
	/** maps word to percentile */
	//public static Map<String, Integer> mapPercentile;
	public static Map<Integer, Map<String, Integer>> mapPercentileByLength;
	
	public static Map<String, Integer> prefixes;
	public static Map<Integer, List<String>> byLength;
	public static List<String> keys;
	
	public static List<String> ignored;
	
	static Random random;
	static { random = new Random(); }

	public static String WORDS1 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/all.num.o5"; // british corpus  see http://www.kilgarriff.co.uk/bnc-readme.html
	public static String WORDS2 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/google-books-common-words.txt"; // google books word count from http://norvig.com/mayzner.html
	public static String WORDS3 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/wiktionary-word-frequencies/words.txt"; // list of wiktionary word frequencies
	
	// Words from Zodiac correspondences (generated by glurk and doranchak) (4 or more letters each)
	public static String WORDS4 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/zodiac-words-of-interest.txt"; // 
	
	// seuss words
	public static String WORDS5 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/seuss-words.txt"; // 
	// practical cryptography (700,000+ words)
	public static String WORDS6 = "/Users/doranchak/projects/zodiac/github/zodiac-killer-ciphers/docs/dictionaries/english_words__practicalcryptography.txt"; // 

	// Zodiac words with counts
	public static String ZODIAC_WORDS_WITH_COUNTS = "/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/dictionaries/zodiac-words-with-counts.txt"; // 
	
	/** zodiac words */
	public static Set<String> zodiacWords = new HashSet<String>();
	public static Set<String> zodiacWordsPrefixes = new HashSet<String>();
	public static String allZodiacWords = "/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/letters/all-words.txt";
	
	/** init only with words from the Zodiac corpus */
	public static void initZodiac() {
		init(WORDS4, Integer.MAX_VALUE, false);
	}
	/** init only with words from the Suess corpus */
	public static void initSuess() {
		init(WORDS5, Integer.MAX_VALUE, false);
	}
	
	/** a suitable default */
	public static void init() {
		init(Integer.MAX_VALUE);
	}
	public static void init(int maxWords) {
		if (map != null && prefixes != null) return;
		mapPercentileByLength = new HashMap<Integer, Map<String, Integer>>();
		WordFrequencies.init(WORDS6, maxWords, false);
		map = sortByValue(map, true);
		for (Map<String, Integer> mapPercentile : mapPercentileByLength.values())
			mapPercentile = sortByValue(mapPercentile, true);
	}
	
	/** stop at maxWords (if we only want to keep the top N popular words, for example */
	public static void init(String wordFile, int maxWords, boolean merge) {
		if (map != null && prefixes != null) return;
		System.out.println("Loading from " + wordFile);
		map = new HashMap<String, Integer>();
		prefixes = new HashMap<String, Integer>();
		byLength = new HashMap<Integer, List<String>>();
		ignored = new ArrayList<String>();
		List<String> words = FileUtil.loadFrom(wordFile);
		int count = 0;
		for (String line : words) {
			//if (line.contains("WHOLE_CORPUS")) continue;
			String[] split = line.split(" ");
			
			String word = split[0];
			if (SCRUB) word = scrub(word.toUpperCase()); // deaccent if desired
			
			if (ignore(word)) {
				//System.out.println("Ignoring " + word);
				ignored.add(word);
				continue;
			}
			if (map.containsKey(word)) continue; // in case deaccenting causes dupes.  prefer first encountered copy since it has higher frequency.
			boolean seen = false;
			int freq = Integer.valueOf(split[1]);
			String key = word; //scrub(word.toUpperCase());

			map.put(key, freq);
			prefix(key, freq);
			List<String> list = byLength.get(key.length());
			if (list == null) list = new ArrayList<String>();
			if (!seen) list.add(key);
			byLength.put(key.length(), list);
			
			count++;
			if (count > maxWords) break;
			
		}
		if (merge) merge();
		for (Integer length : byLength.keySet())
			computePercentiles(length);
		//for (String key : map.keySet()) System.out.println(key +", " + map.get(key));
	}
	
	/** for the given word length:  
	 * sort list of words of that length by frequency, then compute
	 * a percentile score for each word.  this way we can do things like exclude obscure words
	 * that are in the bottom 10%. 
	 */
	static void computePercentiles(int length) {
		Map<String, Integer> mapPercentile = new HashMap<String, Integer>();
		mapPercentileByLength.put(length, mapPercentile);
		// for (Integer L : byLength.keySet()) {
		// List<String> words = byLength.get(L);
		List<String> words = new ArrayList<String>();
		for (String word : map.keySet()) {
			if (word.length() == length)
				words.add(word);
		}

		List<Object[]> list = new ArrayList<Object[]>();
		for (String word : words) {
			list.add(new Object[] { word, freq(word) });
		}
		Collections.sort(list, new Comparator<Object[]>() {

			@Override
			public int compare(Object[] o1, Object[] o2) {
				int i1 = (int) o1[1];
				int i2 = (int) o2[1];
				return Integer.compare(i2, i1);
			}
		});

		// for (Object[] o : list) {
		// System.out.println(L + ", " + o[0] + ", " + o[1]);
		// }

		for (int i = 0; i < list.size(); i++) {
			String word = (String) list.get(i)[0];

			int p;
			if (list.size() == 1)
				p = 100;
			else {
				float pf = 100 - (float) Math.ceil(((float) 100) * i / (list.size() - 1));
				p = (int) pf;
			}

			mapPercentile.put(word, p);
			// System.out.println(word + ", " + p);
		}
	}
	
	static void prefix(String key, int freq) {
		for (int i=1; i<=key.length(); i++) {
			String prefix = key.substring(0,i);
			Integer val = prefixes.get(prefix);
			if (val == null) val = 0;
			val = Math.max(val, freq);
			prefixes.put(prefix, val);
		}
		
		
	}
	
	/** ignore certain words */
	public static boolean ignore(String word) {
		return word.matches(".*[0-9].*");		
	}
	
	/** first corpus is loaded, so merge missing words from others */
	public static void merge() {
		//System.out.println("size " + map.size());
		//System.out.println("ignored before merge: " + ignored.size());
		List<String> lines = FileUtil.loadFrom(WORDS2);
		
		int mostRecentFreq = 0;
		
		for (String line : lines) {
			String[] split = line.split("\\t");
			String word = split[0];
			if (ignore(word)) {
				ignored.add(word);
				continue;
			}
			word = scrub(word);
			if (hasWord(word)) {
				mostRecentFreq = freq(word);
				//System.out.println("Already had " + word + " with freq " + mostRecentFreq);
				continue;
			}
			map.put(word, mostRecentFreq);
			prefix(word, mostRecentFreq);
			//System.out.println("Google Books corpus: Missing word " + word + " at freq " + mostRecentFreq);
			
		}
		
		//System.out.println("size " + map.size());
		lines = FileUtil.loadFrom(WORDS3);
		
		mostRecentFreq = 0;
		
		for (String line : lines) {
			String[] split = line.split(" ");
			String word = split[0].toUpperCase();
			if (ignore(word)) {
				ignored.add(word);
				continue;
			}
			word = scrub(word);
			if (hasWord(word)) {
				mostRecentFreq = freq(word);
				//System.out.println("Already had " + word + " with freq " + mostRecentFreq);
				continue;
			}
			map.put(word, mostRecentFreq);
			prefix(word, mostRecentFreq);
			//System.out.println("Wiktionary: Missing word " + word + " at freq " + mostRecentFreq);
			
		}
		//System.out.println("ignored after merge: " + ignored.size());
		//System.out.println("size " + map.size());
		
		
		
	}
	
	public static String scrub(String word) {
		return FileUtil.convert(word).toString();
	}

	public static boolean hasPrefix(String prefix) {
		return prefixes.keySet().contains(prefix.toUpperCase());
	}
	public static boolean hasWord(String word) {
		return map.keySet().contains(word.toUpperCase());
	}
	/** return number of times the given word appears in the given string */
	public static int occurrencesIn(String str, String word) {
		int count = 0;
		int index = str.indexOf(word);
		while (index > -1) {
			count++;
			index = str.indexOf(word, index+1);
		}
		return count;
	}
	
	/** return frequency of the given word */
	public static int freq(String word) {
		String key = FileUtil.convert(word).toString();
		Integer val = map.get(key);
		if (val == null) return 0;
		return val;
	}
	
	
	public static List<WordBean> findAllWordsIn(String str, int minLength, boolean sort) {
		init();
		List<WordBean> beans = new ArrayList<WordBean>();
		str = str.toUpperCase();
		for (String word : map.keySet()) {
			if (word.length() < minLength) continue;
			if (str.contains(word)) {
				WordBean bean = new WordBean();
				bean.word = word;
				bean.frequency = freq(word);
				bean.percentile = percentile(word);
				beans.add(bean);
			}
		}
		if (sort) Collections.sort(beans);
		return beans;
	}
	
	/** same as findAllWordsIn but return results in order they appear in input string */
	public static List<WordBean> findAllWordsInOrder(String str, int minLength, int minFrequency) {
		init();
		List<WordBean> beans = new ArrayList<WordBean>();
		str = str.toUpperCase();
		for (int pos1=0; pos1<str.length()-minLength+1; pos1++) {
			for (int pos2=pos1+minLength; pos2<str.length(); pos2++) {
				String word = str.substring(pos1, pos2);
				if (!prefixes.containsKey(word)) continue;
				if (map.containsKey(word)) {
					int freq = freq(word);
					if (freq < minFrequency) continue;
					WordBean bean = new WordBean();
					bean.word = word;
					bean.frequency = freq;
					bean.percentile = percentile(word);
					beans.add(bean);
				}
			}
					
		}
		return beans;
	}
	/* same but filter by percentile instead of frequency */
	public static List<WordBean> findAllWordsInOrder2(String str, int minLength, int minPercentile) {
		init();
		List<WordBean> beans = new ArrayList<WordBean>();
		str = str.toUpperCase();
		for (int pos1=0; pos1<str.length()-minLength+1; pos1++) {
			for (int pos2=pos1+minLength; pos2<str.length(); pos2++) {
				String word = str.substring(pos1, pos2);
				if (!prefixes.containsKey(word)) continue;
				if (map.containsKey(word)) {
					int percentile = percentile(word);
					if (percentile < minPercentile) continue;
					WordBean bean = new WordBean();
					bean.word = word;
					bean.frequency = freq(word);
					bean.percentile = percentile(word);
					beans.add(bean);
				}
			}
					
		}
		return beans;
	}
	
	/** find all words that fall within the given levenstein distance range */ 
	public static List<WordBean> findAllFuzzyWordsIn(String str, int minLength,
			int minDistance, int maxDistance, boolean sort,
			boolean enforceLength) {
		init();
		List<WordBean> beans = new ArrayList<WordBean>();
		str = str.toUpperCase();
		int total = map.size();
		int num = 0;
		System.out.println("Searching for " + total + " words...");
		for (String word : map.keySet()) {
			num++;
			if (num % 5000 == 0) System.out.println(num + "...");
			if (word.length() < minLength) continue;
			int fuzzyMinLength = enforceLength ? word.length() : (word.length() - maxDistance);
			int fuzzyMaxLength = enforceLength ? word.length() : (word.length() + maxDistance);
			for (int len=fuzzyMinLength; len<=fuzzyMaxLength; len++) {
				for (int i=0; i<str.length()-len+1; i++) {
					String sub = str.substring(i,i+len);
					int ld = StringUtils.getLevenshteinDistance(sub, word);
					if (ld >= minDistance && ld <= maxDistance) {
						WordBean bean = new WordBean();
						bean.word = word;
						bean.frequency = freq(word);
						bean.percentile = percentile(word);
						bean.levensteinDistance = ld;
						bean.fuzzyWord = sub;
						bean.pos = i;
						beans.add(bean);
						//System.out.println(bean);
					}
				}
			}
		}
		if (sort) Collections.sort(beans);
		return beans;
	}
	
	public static void findAllWordsIn(String str, int minLength) {
		init();
		str = str.toUpperCase();
		for (String word : map.keySet()) {
			if (word.length() < minLength) continue;
			if (str.contains(word)) {
				System.out.println(word.length() + "	" + freq(word) + "	" + word);
			}
		}
	}

	/** for each line in file, display all words found in that line */
	public static void findAllWordsInFile(String filePath, int minLength, boolean printAllWords, boolean showSummary) {
		init();
		String tab = "	";
		Map<String, Integer> counts = new HashMap<String, Integer>(); // word counts
		Map<Integer, List<WordBean>> foundWords = new HashMap<Integer, List<WordBean>>(); // lists of words by length 

		BufferedReader input = null;
		int counter = 0;
		int maxLength = 0;
		try {
			input = new BufferedReader(
			           new InputStreamReader(new FileInputStream(filePath), "UTF-8"));
			String line = null; // not declared within while loop
			while ((line = input.readLine()) != null) {
				counter++;
				List<WordBean> words = findAllWordsInOrder(line, minLength, -1);
				for (WordBean word : words) {
					if (printAllWords) System.out.println(word.word.length() + tab + word.frequency + tab + word.word);
					if (showSummary) {
						if (word.word.length() > maxLength) maxLength = word.word.length();
						Integer count = counts.get(word.word);
						if (count == null) {
							count = 0;
							List<WordBean> list = foundWords.get(word.word.length());
							if (list == null) {
								list = new ArrayList<WordBean>();
								foundWords.put(word.word.length(), list);
							}
							list.add(word);
							System.out.println("FOUND: " + word);
						}
						count++;
						counts.put(word.word, count);
					}
				}
			}
			System.out.println("read " + counter + " lines.");
		} catch (FileNotFoundException ex) {
			ex.printStackTrace();
		} catch (IOException ex) {
			ex.printStackTrace();
		} 
		
		try {
			input.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		if (showSummary) {
			System.out.println("============ SUMMARY OF FOUND WORDS: ");
			for (int L = maxLength; L >= minLength; L--) {
				System.out.println("LENGTH " + L + ":");
				Collections.sort(foundWords.get(L), new Comparator<WordBean>() {
					@Override
					public int compare(WordBean o1, WordBean o2) {
						// TODO Auto-generated method stub
						return Integer.compare(o2.frequency, o1.frequency);
					}
					
				});
				//System.out.println(foundWords.get(L));
				for (WordBean word : foundWords.get(L)) {
					System.out.println(L + tab + word.word + tab + counts.get(word.word)+ tab + word.frequency);
				}
			}
		}
	}
	
	/** return percentile score for the given word */
	public static int percentile(String word) {
		int length = word.length();
		Map<String, Integer> mapPercentile = mapPercentileByLength.get(length);
		if (mapPercentile == null) return 0;
		String key = FileUtil.convert(word).toString();
		Integer p = mapPercentile.get(key);
		//System.out.println("percentile for " + key + " is " + p + " or " + mapPercentile.get(key.toLowerCase()));
		if (p == null) return 0;
		return p;
	}

	/** return a random word */ 
	public static String randomWord() {
		if (keys == null) keys = new ArrayList<String>(map.keySet());
		return keys.get(random.nextInt(keys.size()));
	}
	/** return a random word with the given minimum percentile */ 
	public static String randomWord(int percentile) {
		if (keys == null) keys = new ArrayList<String>(map.keySet());
		while (true) {
			String word = keys.get(random.nextInt(keys.size()));
			if (percentile(word) >= percentile) return word;
		}
	}
	/** return a random word with the given length and minimum percentile */ 
	public static String randomWord(int length, int percentile) {
		while (true) {
			String word = byLength.get(length).get(random.nextInt(byLength.get(length).size()));
			if (percentile(word) >= percentile) return word;
		}
	}
	
	/** returns true if word has no non-alphabetic characters */
	public static boolean isAlpha(String word) {
		return word.matches("^[A-Z]*$");
	}

	
    public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map, boolean reverse) {
        List<Entry<K, V>> list = new ArrayList<>(map.entrySet());
        list.sort(Entry.comparingByValue());
        if (reverse) Collections.reverse(list);

        Map<K, V> result = new LinkedHashMap<>();
        for (Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }

        return result;
    }	
	
	/** sort the words by length descending.  within each length, sort by frequency descending. */
	public static List<WordBean> sort(List<String> words) {
		List<WordBean> beans = new ArrayList<WordBean>();
		for (String word : words) {
			WordBean bean = new WordBean();
			bean.word = word;
			bean.frequency = freq(word);
			beans.add(bean);
		}
		Collections.sort(beans);
		return beans;
	}
	/** pretty print a list of wordbeans. */
	public static void prettyPrint(List<WordBean> words) {
		Collections.sort(words);
		int L=-1;
		StringBuffer line = new StringBuffer();
		for (WordBean bean : words) {
			if (bean.word.length() != L) {
				if (L>0) System.out.println("Length " + L + ": " + line);
				line = new StringBuffer();
				L=bean.word.length();
			}
			line.append(bean.word);
			line.append(" ");
		}
		System.out.println("Length " + L + ": " + line);
	}
	
	/** read a list of words and print out their frequencies */
	public static void processWords(String file) {
		List<String> list = FileUtil.loadFrom(file);
		for (String word : list) {
			System.out.println(FileUtil.convert(word) + ", " + freq(word));
		}
	}
	
	public static class WordBean implements Comparable {
		public String word;
		public int frequency;
		public int percentile;
		public int levensteinDistance; // for fuzzy searches
		public String fuzzyWord; // the fuzzy word that matched an actual word
		public int pos;
		@Override
		public int compareTo(Object o) {
			WordBean word1 = this;
			WordBean word2 = (WordBean) o;
			
			if (word1.word.length() > word2.word.length()) return -1;
			if (word1.word.length() < word2.word.length()) return 1;
			return Integer.compare(word2.frequency, word1.frequency);
		}
		public String toString() {
			String result = word.length() + " " + frequency + " " + percentile + " " + pos + " " + word;
			if (fuzzyWord != null)
				result += " " + levensteinDistance + " [" + fuzzyWord + "]";
			return result;
		}
		
	}

	private static Map<Character, Character> keyFrom(List<String> cipherWords, List<String> plainWords) {
		Map<Character, Character> key = new HashMap<Character, Character>();
		if (cipherWords == null) return key;
		if (plainWords == null) return key;
		
		for (int i=0; i<plainWords.size(); i++) {
			String cipher = cipherWords.get(i);
			String plain = plainWords.get(i);
			for (int j=0; j<cipher.length(); j++) {
				key.put(cipher.charAt(j), plain.charAt(j));
			}
		}
		return key;
	}
	/** crack given list of cipher words using brute force substitutions */
	public static void crack(List<String> cipherWords) {
		init();
		//Map<Character, Character> c2p = new HashMap<Character, Character>();
		List<String> plainWords = new ArrayList<String>();
		crack(cipherWords, plainWords, 0, 0);
	}
	
	private static void crack(List<String> cipherWords, List<String> plainWords, int start, int score) {
		if (start == cipherWords.size()) return;
		
		String cipher = cipherWords.get(start);
		for (String word : map.keySet()) {
			if (word.length() != cipher.length()) continue;
			
			boolean go = true;
			for (int i=0; i<cipher.length(); i++) {
				for (int j=i+1; j<cipher.length(); j++) {
					if (cipher.charAt(i) == cipher.charAt(j)) {
						if (word.charAt(i) != word.charAt(j)) {
							go = false;
							break;
						}
					}
				}
				if (!go) break;
			}
			if (!go) continue;
			
			// if we got this far, the word fits the constraints of the cipher text
			// now let's apply the partial substitution key if any plaintext words have already been found
			Map<Character, Character> key = keyFrom(cipherWords, plainWords);
			for (int i=0; i<cipher.length(); i++) {
				Character plain = key.get(cipher.charAt(i));
				if (plain == null) continue;
				if (word.charAt(i) != plain) {
					go = false;
					break;
				}
			}
			if (!go) continue;
			
			String indent = "";
			for (int i=0; i<start; i++) indent += "   ";
			int oldscore = score;
			score = score + freq(word);
			System.out.println(indent + "Match: [" + cipher + "], [" + word + "] + [" + freq(word) + "] [" + score + "] " + (start == cipherWords.size()-1 ? " *": ""));
			plainWords.add(word);
			crack(cipherWords, plainWords, start+1, score);
			score = oldscore;
			plainWords.remove(plainWords.size()-1);
		}
	}
	
	// http://jefferyjohnson.net/2013/02/24/
	public static void crackSactech() {
		init();
		List<String> cipher = new ArrayList<String>();
		cipher.add("oteeo)d*");
		cipher.add("_tf*)f");
		//cipher.add("_-f*)");
		//cipher.add("_-r-_e");
		cipher.add(".xeydtxc-");
		crack(cipher);
	}
	
	/** look for WIZARD words; i.e., words that spell themselves in the reverse alphabet */
	public static void findWizardWords() {
		init();
		boolean found = true;
		String line = "";
		for (String word : map.keySet()) {
			if (word.length() < 2) continue;
			found = true;
			line = "";
			for (int i=0; i<word.length()/2; i++) {
				char ch1 = word.toUpperCase().charAt(i);
				char ch2 = word.toUpperCase().charAt(word.length()-1-i);
				int d1 = ((int) ch1)-65;
				int d2 = ((int) ch2)-65;
				line += ch1 + " " + ch2 + " " + d1 + " " + d2 + "; ";
				if (d1 + d2 != 25) {
					found = false;
					break;
				}
			}
			if (found) {
				System.out.println(word.length() + ", " + freq(word) + ", " + word + "   " + line);
			}
		}
	}
	
	/** find all possible collections of adjacent words in the given line of unbroken alphabet characters.
	 * returns results in descending order of a score which includes percentiles scores of words.
	 * 
	 * do not include words whose percentile scores are less than the given value.
	 */
	public static List<PhraseSearchResult> phrasesIn(String line, int percentileCutoff, int depth) {
		List<PhraseSearchResult> list = new ArrayList<PhraseSearchResult>();
		for (int i=0; i<line.length(); i++) {
			//System.out.println(i+"...");
			list.addAll(phrasesIn(line, i, percentileCutoff, depth));
		}
		Collections.sort(list);
		return list;
	}
	
	/** get all possible words that start at the beginning of the given string.  words are returned 
	 * in ascending order of word length.
	 */
	public static List<String> candidateWordsFor(String line, int p) {
		List<String> list = new ArrayList<String>();
		for (int i=1; i<=line.length(); i++) {
			String prefix = line.substring(0,i);
			if (!hasPrefix(prefix)) return list; // no more words can be found
			int percentile = percentile(prefix);
			if (percentile >= p) {
				//System.out.println("Added " + prefix);
				list.add(prefix);
			}
		}
		return list;
	}
	
	static List<PhraseSearchResult> phrasesIn(String line, int position, int percentileCutoff, int maxWords) {
		//System.out.println("pos " + position + " max " + maxWords);
		List<PhraseSearchResult> results = new ArrayList<PhraseSearchResult>();
		if (position >= line.length()) return results;
		if (maxWords < 1) return results;
		
		List<String> candidateWords = candidateWordsFor(line.substring(position), percentileCutoff);
		
		while (!candidateWords.isEmpty()) {
			String candidate = candidateWords.remove(candidateWords.size()-1); // get largest word
			//System.out.println(maxWords + " candidate " + candidate);
			// current candidate is a word
			// first, recurse to find all possible sub-phrases
			// track how many one-letter words we have in a row, to avoid spurious solutions.
			int m = maxWords - 1;
			List<PhraseSearchResult> subphrases = phrasesIn(line, position+candidate.length(), percentileCutoff, m);

			
			
			// the current candidate word is the beginning of all the possible subphrases, so merge them
			for (PhraseSearchResult subphrase : subphrases) {
				PhraseSearchResult merged = new PhraseSearchResult(position);
				merged.add(candidate);
				merged.add(subphrase);
				
				results.add(merged);
				//System.out.println("Just merged " + merged);
			}
			// also, add the current word as its own phrase
			PhraseSearchResult result = new PhraseSearchResult(position);
			result.add(candidate);
			results.add(result);
		
		}
		return results;
	}
	public static void testPhraseSearch() {
		//String line = Ciphers.Z408_SOLUTION;
		//String line = "LSSPAWCNNTSITTHADBUSTOUGHMORTTHOSETTERIORATILLLERESHOTATMYDEADENSOFMETHEOUTMONESALSAIDEAWHIMNOLOSSTHERMRSHREPUEBNIENTIALTHISWANTSMOFLEDHISOLESSLOVICEMAYTSCHARWITNHISRIDORREDINGHITBENOTAFUORULDHTEMOREARYCHESTERHIMORNSENANEWEREANODOASANOUTTHESTATVHDREADEROADEDONCOUITINEVOTTEDCASTEVERREFHOLIMASTOEARISASNSTEDTOWENTAITISPEREDTHALTFORIETRWREMEF";
		String line = "RPATHOMEENORTGTOSAYONEOFORETSRMECANENIFINDBOILFSAYLFOUTTHETOBREALEANCIEUTSFORDTHATHERIGHTHLOVERSHOCATETOGRAYINAMILEWEHINGATTILTHBYLSLLLMENOBOIVROHLADDIFROROFALLITESTHELAOLANCTWMISEDANDATTEWASPANDONETHEDROPARODLFTANCEPTTEAGECAREOFNANTHTHADNOTHITSLINGOATTERAIGBATVDERISNOTLETOONEHISNEEDBEMOREPUTAVERTISTIENONTTHEHETHENOISEFOLDNOTPERISHSLLIASW";
		List<PhraseSearchResult> list = phrasesIn(line, 10, 3);
		
		int count = 0;
		for (PhraseSearchResult result : list) {
			System.out.println(result);
			count++;
			if (count == 1000) break;
		}
	}

	public static void processFragmentResults(int DEPTH) {
		int MAX_PER_FILE = 1000;
		int MAX_ALL = 10000;
		List<PhraseSearchResult> list = new ArrayList<PhraseSearchResult>();
		
		String base = "/Users/doranchak/projects/zodiac/fragment-transformations/results";
		File dir = new File(base);
		File[] files = dir.listFiles();
		for (File file : files) {
			if (file.isDirectory()) continue;
			if (!file.getName().endsWith(".txt")) continue;
			//System.out.println(file.getName());
			List<String> lines = FileUtil.loadFrom(file.getAbsolutePath());
			for (String s : lines) {
				List<PhraseSearchResult> results = phrasesIn(s.split(",")[1], 10, DEPTH);
				for (int i=0; i<results.size() && i<MAX_PER_FILE; i++) {
					list.add(results.get(i));
				}
			}
			//System.out.println(list.size());
		}
		Collections.sort(list);
		int count = 0;
		for (PhraseSearchResult result : list) {
			System.out.println(result);
			count++;
			if (count == MAX_ALL) break;
		}
		
	}
	
	/** find words that fit in pivot pattern if it is flattened out (i.e., "racecar") */ 
	static void pivots() {
		for (String word : map.keySet()) {
			if (word.length() < 7) continue;
			for (int i=0; i<word.length()-6; i++) {
				String sub = word.substring(i,i+7);
				boolean found = true;
				for (int j=0; j<4; j++) {
					char c1 = sub.charAt(j);
					char c2 = sub.charAt(6-j);
					if (c1 != c2) {
						found = false;
						break;
					}
				}
				if (found) {
					String line = "";
					for (int k=0; k<word.length(); k++) {
						if (k==i) line += "[";
						line += word.charAt(k);
						if (k==i+6) line += "]";
					}
					System.out.println(freq(word) + " " + word + ": " + line);
				}
			}
		}
	}
	
	static void testMorf() {
		for (String word : map.keySet()) {
			if (word.matches(".*E.LL.*"))
				System.out.println(freq(word) + " " + word);
		}
	}
	
	/** return unique words with the given minimum percentile */
	public static Set<String> wordsWithMinPercentile(String str, int minLength, int maxLength, int minPercentile) {
		init();
		Set<String> words = new HashSet<String>();
		if (str == null || str.isEmpty()) return words; 
		for (int L=minLength; L<=maxLength; L++) {
			for (int i=0; i<str.length()-L+1; i++) {
				String word = str.substring(i,i+L);
				//System.out.println(word);
				if (words.contains(word)) continue;
				if (!hasWord(word)) continue;
				if (percentile(word) < minPercentile) continue;
				words.add(word);
			}
		}
		return words;
	}
	
	public static void testFuzzy(String str) {
		System.out.println("Searching in " + str);
		List<WordBean> beans = findAllFuzzyWordsIn(
		// "yesernsatedinmaporecongrougestbeallareathetalwhisputinformonthewwhatweredtonisaliveswildsomensreallbadticchristandwhorainstlarrymoonlytwodientmpplayingtosteninunionisislamwillapplyjobsuseandathehareantherslefoothihadnersfreemerstanthrtanimagroupforthreealistoowereoptheoffleaiscommesownwhytheitsnotspecttheinforisthepostersunitrepressatipno",
		// // mine
		// "utitsrawhileotdrshelordsandestinasmoralliesimhertruckingspandithinktheynotgoandmaketheylisttosetomyillhellybeatgoodearlyresmarsitssomuchsornotpromananddatteryouresofarswithasmorefuckingitwolatenilbelockisamethatiredonestobetterncondistoryaddsmuchashistelypasswhereareinagamewashappetsdoneupieationtarentcityofawaitingsidessuretingstandtyrog",
		// // jarlve
				str.toLowerCase(), 5, 0, 1, true, false);

		// String result = "";
		String prevWord = null;
		for (WordBean bean : beans) {
			if (prevWord == null || !prevWord.equals(bean.word)) {
				System.out.println();
				System.out.print(bean.word.length() + " " + bean.percentile + " " + bean.pos + " " + bean.word + " ");
				prevWord = bean.word;
			}
			System.out.print("[" + bean.fuzzyWord + "] ");
		}
	}
	
	public static void findWords(String str, int minWordLength) {
		List<WordBean> beans = findAllWordsIn(str, minWordLength, true);
		for (WordBean bean : beans)
			System.out.println(bean);

	}
	
	/** https://www.facebook.com/photo.php?fbid=10208737179419395&set=a.1465662814097.59617.1609332208&type=3 */
	public static void patternMatch() {
		init();
		for (String word1 : map.keySet()) {
			if (word1.length() == 6) {
				StringBuffer sb = new StringBuffer(word1);
				char[] c1 = sb.toString().toCharArray(); 
				if (c1[0] == c1[3] && c1[2] == c1[4]) {
					System.out.println(freq(word1) + " " + word1);
					/*for (String word2 : map.keySet()) {
						if (word2.length() == 6) {
							sb = new StringBuffer(word2);
							char[] c2 = sb.reverse().toString().toCharArray();
							// cshchq
							// hchqsb
							if (c2[0] == c2[2] && c2[2] == c2[4]) {
								if (c1[0] == c2[1] && c1[1] == c2[4] && c1[2] == c2[0]) {
									System.out.println(" - " + (freq(word1) + freq(word2)) + " " + freq(word1) + " " + freq(word2) + " " + word1 + " " + word2);
								}
	
							}
						}
	
					}*/
				}
			}
		}
	}

	public static void patternMatch2() {
		init();
		int count = 0;
		for (String word1 : map.keySet()) {
			if (word1.length() == 6) {
				for (String word2 : map.keySet()) {
					if (word2.length() == 6) {
						if (word1.substring(2).equals(word2.substring(0, 4))) {
							
							if (word1.charAt(0) == word2.charAt(1) && word1.charAt(1) == word2.charAt(4)) {
								System.out.println((freq(word1) + freq(word2))
										+ " " + word1 + " " + word2);
								
							}
							
						}
					}
				}
			}
		}
	}
	/** http://scienceblogs.de/klausis-krypto-kolumne/2017/11/26/who-can-decipher-this-ecrypted-inscription-on-a-cigaret-case/ */
	public static void patternMatch3() {
		/*
		 	shwshl
			/t|~w/
			h4wo+
			h~/33=~=h~4hn
			+h8~hh/
			%0
			4n=s3|

		 */
		init();
		int count = 0;
		long score = 1;
		
		for (String word1 : map.keySet()) {
			// h~/33=~=h~4hn
			if (word1.length() == 13) {
				if (word1.charAt(0) == word1.charAt(8) && word1.charAt(0) == word1.charAt(11)) {
					System.out.println(word1);
					if (word1.charAt(3) == word1.charAt(4)) {
						System.out.println("	" + word1);
						
					}
				}
			}
		}
		if (1==1) return;
		
		for (String word1 : map.keySet()) {
			if (word1.length() == 6) {
				if (word1.charAt(0) == word1.charAt(3) && word1.charAt(1) == word1.charAt(4)) {
//					System.out.println(word1);
					for (String word2 : map.keySet()) {
						if (word2.length() == 5) {
							if (word2.charAt(0) == word1.charAt(1) && word2.charAt(2) == word1.charAt(2)) {
//								System.out.println("	" + word2);
								
								// +h8~hh/
								for (String word3 : map.keySet()) {
									if (word3.length() == 6) {
										if (word3.charAt(1) == word2.charAt(0) && word3.charAt(4) == word2.charAt(0) && word3.charAt(5) == word2.charAt(0)) {
											String suffix = word3.charAt(1) == 'E' ? "	SMEG" : "";
											score = freq(word1) * freq(word2) * freq(word3);
											System.out.println(score + "	" + word1 + "	" + word2 + "	" + word3 + suffix);
										}
									}
								}								
								
							}
						}
					}
					
				}
			}
		}
	}
	public static void patternMatch4() {
		init();
		for (String word1 : map.keySet()) {
			if (word1.length() == 8) {
				StringBuffer sb = new StringBuffer(word1);
				char[] c1 = sb.toString().toCharArray(); 
				if (c1[3] == c1[5] && c1[6] == c1[7]) {
					System.out.println(freq(word1) + " " + word1);
				}
			}
		}
	}
	
	public static void testPatternCombinations() {
		String[] words = new String[] { "EFCGH",
				"FIJFJC",
				"GEGKIL",
				"JFJCIE",
				"MINJ",
				"MIC",
				"OGENCPK"};
		for (int i=0; i<words.length-2; i++) {
			for (int j=i+1; j<words.length-1; j++) {
				for (int a=j+1; a<words.length; a++) {
				Set<Character> set = new HashSet<Character>();
				String str = words[i] + words[j] + words[a];
				for (int k=0; k<str.length(); k++) {
					set.add(str.charAt(k));
				}
				float ratio = ((float)set.size())/str.length();
				System.out.println(ratio + " " + words[i] + " " + words[j] + " " + words[a]);
				}
			}
		}
	}

	public static void initZodiacWords() {
		if (zodiacWords == null || zodiacWords.isEmpty()) {
			BufferedReader input = null;
			
			try {
				input = new BufferedReader(new FileReader(new File(allZodiacWords)));
				String line = null; // not declared within while loop
				while ((line = input.readLine()) != null) {
					String word = line.toUpperCase();
					zodiacWords.add(word);
					for (int i = 1; i <= word.length(); i++) {
						zodiacWordsPrefixes.add(word.substring(0, i));
					}
				}
				// System.out.println("read " + counter + " lines.");
			} catch (FileNotFoundException ex) {
				ex.printStackTrace();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
			try {
				input.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
			
		}
	}
	public static void findZodiacWordsInFiles(String file) {
		initZodiacWords();
		System.out.println(zodiacWords);
		BufferedReader input = null;
		try {
			input = new BufferedReader(new FileReader(new File(file)));
			String line = null; // not declared within while loop
			while ((line = input.readLine()) != null) {
				Map<Integer, Integer> countsByLength = new HashMap<Integer, Integer>(); 
				line = line.toLowerCase();
				long score = 0;
				String found = "";
				for (String word : zodiacWords) {
					word = word.toLowerCase();
					if (line.contains(word)) {
						found += word + " ";
						Integer key = word.length();
						Integer val = countsByLength.get(key);
						if (val == null) val = 0;
						val++;
						countsByLength.put(key,val);
					}
				}
				for (Integer key : countsByLength.keySet()) {
					score += Math.pow(countsByLength.get(key), key-3);
				}
				System.out.println(score + " " + found + " " + line);
			}
			
		} catch (FileNotFoundException ex) {
			ex.printStackTrace();
		} catch (IOException ex) {
			ex.printStackTrace();
		}

		try {
			input.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		
	}
	public static List<WordBean> findZodiacWordsIn(String line) {
		initZodiacWords();
		List<WordBean> list = findAllWordsIn(line, 4, true);
		List<WordBean> result = new ArrayList<WordBean>();
		for (WordBean bean : list) 
			if (zodiacWords.contains(bean.word)) result.add(bean);
		return result;
	}
	// faster version of findZodiacWordsIn
	public static List<WordBean> findZodiacWordsFasterIn(String line) {
		initZodiacWords();
		List<WordBean> beans = new ArrayList<WordBean>();
		
		for (int a=0; a<line.length(); a++) {
			for (int b=a+1; b<=line.length(); b++) {
				String sub = line.substring(a, b);
				if (!zodiacWordsPrefixes.contains(sub)) continue;
				if (zodiacWords.contains(sub)) {
					WordBean bean = new WordBean();
					bean.word = sub;
					bean.frequency = freq(sub);
					bean.percentile = percentile(sub);
					bean.pos = a;
					beans.add(bean);
				}
			}
		}
		
		return beans;
	}
	
	public static void headlines() {
		init();
		List<String> lines = FileUtil.loadFrom("/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/ciphers/classifier-samples/headline-puzzles/headlines.txt");
		for (String line : lines) {
			//if (!line.contains("PRWPDJC")) continue;
			double score = 0;
			String[] split = line.split(" ");
			for (String word : split) {
				if (word.length() < 3) continue;
				word = FileUtil.convert(word).toString();
				int freq = freq(word);
				if (freq > 0)
					score += Math.log(freq);
				//System.out.println(freq(word) + " " + word);
			}
			System.out.println(score + "  " + line);
		}
		
	}

	public static String decode(String num) {
		if ("1".equals(num)) return "JF";
		if ("2".equals(num)) return "MA";
		if ("3".equals(num)) return "MJ";
		if ("4".equals(num)) return "JA";
		if ("5".equals(num)) return "SO";
		if ("6".equals(num)) return "ND";
		return "WTF???";
	}
	public static void issues() {
		init();
		List<String> lines = FileUtil.loadFrom("/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/ciphers/classifier-samples/aca-cons/list");
		for (String line : lines) {
			String[] split = line.split(" ");
			String out = decode(split[1]) + split[0].substring(2);
			System.out.println(out);
		}
		
	}
	
	/** zodiac-like cipher someone sent me */
	public static void testZodiaclike() {
		init();
		for (String word : map.keySet()) {
			if (word.length() != 5) continue;
			char[] c = word.toCharArray();
			if (c[0] == c[1] && c[0] == c[3]) {
				System.out.println(freq(word) + " " + word);
			}
		}
	}
	
	//http://scienceblogs.de/klausis-krypto-kolumne/files/2017/09/Rinzi-Cryptogram-03.jpg
	public static void rinzi() {
		init();
		for (String word : map.keySet()) {
			if (word.length() != 7) continue;
			if (word.charAt(0) == word.charAt(6) && word.charAt(2) == word.charAt(4)) {
				System.out.println(freq(word) + " " + word);
			}
		}
	}

	/** split given string into words based on spaces.
	 * return product of percentiles for each word (minimum percentile is 1)  
	 */
	public static float score(String str) {
		if (str == null) return 0;
		String[] split = str.split(" ");
		float p = 1;
		for (String s : split) {
			if (s.length() < 3) continue;
			p *= (1 + WordFrequencies.percentile(s));
		}
		return p;
	}
	/** split given string into words based on spaces.
	 * return log of product of percentiles for each word (minimum percentile is 1)  
	 */
	public static float scoreLog(String str) {
		if (str == null) return 0;
		String[] split = str.split(" ");
		float p = 0;
		for (String s : split) {
			if (s.length() < 3) continue;
			p += Math.log(1 + WordFrequencies.percentile(s));
		}
		return p;
	}
	/** recursively find the best word divisions of the given non-delimited text
	 * based on percentile scores of each candidate word.
	 * min length of words is 3. 
	 */
	public static String bestWords(String line) {
		ResultBean bean = new ResultBean();
		bestWords(line, "", bean);
		return bean.toString();
	}
	public static void bestWords(String line, String words, ResultBean result) {
		if (line.length() < 3) {
			result.check(score(words + line), words+line);
			return;
		}
		for (int i=3; i<line.length(); i++) {
			String chunk = line.substring(0, i);
//			float p2 = 1 + WordFrequencies.percentile(chunk);
			bestWords(line.substring(i), words + " " + chunk, result);
		}
		
	}
	
	// find words that, when letters are treated as Z408's / Z340's symbols, decode to other words
	public static void findZWordsThatDecodeToOtherWords() {
		init();
		Map<Character, Character> key408 = Ciphers.decoderMapFor(Ciphers.Z408, Ciphers.Z408_SOLUTION.toUpperCase());
		Map<Character, Character> key340 = Z340Solution.z340SolutionKey();
		System.out.println(key340);
		System.out.println(key408);
		for (String word : map.keySet()) {
			String word408 = Ciphers.decode(word, key408);
			String word340 = Ciphers.decode(word, key340);
			
			long f1 = freq(word);
			long f2 = freq(word408);
			long f3 = freq(word340);
			
			long s1 = (f1+1)*(f2+1);
			long s2 = (f1+1)*(f3+1);
			
			if (hasWord(word408)) {
				System.out.println(word.length() + " " + s1 + " " + word + " " + word408 + " " + 408);
			}
			if (hasWord(word340)) {
				System.out.println(word.length() + " " + s2 + " " + word + " " + word340 + " " + 340);
			}
		}
	}

//	// all the ways to split the line into words of any length
//	public static String bestWords2(String line) {
//		ResultBean bean = new ResultBean();
//		bestWords2(new StringBuffer(line), "", "", bean);
//		return bean.toString();
//	}
//	public static void bestWords2(StringBuffer line, String left, String right, ResultBean result) {
////		System.out.println("line [" + line + "] left [" + left + "] right [" + right + "]");
//		if (line.length() < 2) {
//			return;
//		}
//		
//		// 1) consider the entire line
//		System.out.println(left + " " + line + " " + right);
//		
//		// 2) consider all split points between letters in the line.
//		// for each one, consider the chunk to the left, and then the one to the right.
//		
//		for (int i=2; i<line.length()-2; i++) {
//			line.insert(i, ' ');
//			String left2 = line.substring(0, i);
//			String right2 = line.substring(i+1);
////			System.out.println("left2 " + left2 + " right2 " + right2);
//			bestWords2(new StringBuffer(left2), left, right2 + " " + right, result);
//			bestWords2(new StringBuffer(right2), left + " " + left2, right, result);
//			line.delete(i, i+1);
//		}
//		
//	}

	/** print out ioc of words of the given length */
	public static void highIocWords(int length) {
		init();
		for (String word : map.keySet()) {
			if (word.length() != length) continue;
			int p = percentile(word);
			if (p < 80) continue;
			if (Ciphers.alphabet(word).length() < 5)
				System.out.println(Stats.ioc(word) + " " + p + " " + word);
		}
	}
	public static void findWordsWithDoubledLetters() {
		init();
		for (String word : map.keySet()) {
			int count = doublesIn(word);
			if (count > 0 && percentile(word) > 85) {
				System.out.println(count + "	" + percentile(word) + "	" + word);
			}
		}
	}
	public static int doublesIn(String word) {
		int count = 0;
		for (int i=1; i<word.length(); i++) {
			if (word.charAt(i) == word.charAt(i-1)) {
				count++;
			}
		}
		return count;
	}
	/** find all words that can appear in the given string with their letters in the same order, with any number of other letters in between */
	public static void findGasStationSignWordsIn(String str, int minLength) {
		for (String word : map.keySet()) {
			boolean found = true;
			int index = 0;
			for (int i=0; i<word.length(); i++) {
				char ch = word.charAt(i);
				index = str.indexOf(ch, index);
				if (index < 0) {
					found = false;
					break;
				}
				index++;
			}
			if (found) {
				System.out.println(word.length() + "	" + freq(word) + "	" + word);
			}
		}
	}
	public static void testFindGasStationSignWordsIn() {
		WordFrequencies.init();
		findGasStationSignWordsIn("NO EVERYTHING IM IS POSSIBLE", 3);
	}
	
	public static void main(String[] args) {
		testFindGasStationSignWordsIn();
//		WordFrequencies.init();
//		System.out.println(WordFrequencies.bestWords("DEARQYZPOOPATFACE"));
//		System.out.println(scoreLog("TRESPASS AGAINST US AND LEAD US NOT INTO TEMPTATION BUT DELIVER US FROM EVIL FOR THINE IS THE KINGDOM THE POWER AND THE"));
//		System.out.println(scoreLog("TRESPASS AGAINST US AND LEAD US NOT INTO TEMPTATION BUT DELIVER US FROM EVIL FOR THINE IS THE KINGDOM THE POWER AND THE GLORY"));
//		patternMatch4();
//		highIocWords(13);
		//init();
//		bestWords2("DEARQYZPOOPATFACE");
//		bestWords2("ABC");
//		patternMatch3();
		//rinzi();
		//WordFrequencies.init("/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/dictionaries/all.num.o5");
//		init();
//		System.out.println(prefixes.size() + ", " + map.size());
//		System.out.println(prefixes.get("HER"));
//		
//		for (String word : map.keySet()) {
//			if (word.length() != 8) continue;
//			if (word.charAt(0) == word.charAt(2) && word.charAt(2) == word.charAt(7)) {
//				if (word.charAt(3) == word.charAt(5) && word.charAt(5) == word.charAt(6)) {
//					System.out.println(word);
//				}
//			}
//		}
		
		//System.out.println(w.freq("yum"));
		//WordFrequencies.processWords("/Users/doranchak/projects/zodiac/zodiac-killer-ciphers/docs/ray-grant/myth-words-all-1.txt");
		//crackSactech();
		//findWizardWords();
		//init();
		//System.out.println(map.size());
		//System.out.println(prefixes.get("HANDYMAN"));
		//testPhraseSearch();
		//testMorf();
		//processFragmentResults(Integer.valueOf(args[0]));
		//findAllWordsIn("ndenndoutforheallthmaillfisallionstsiinsinprusatproducoriescounthecomhidioaratesaddanthesoutrairsgauthsaatontateopedorigoitsemphelesseetheredhernsdesaccthesehasdritanearlsantternatupisantagertimattsouthpotproteanangerforesumpisandthistheacanicetctousomnusairedadedcherstactssusaanisaigalsandrehilustanningsaroulddonoppoliceasedtheationscram");
		
		//WordFrequencies.init();
		/*for (String word : map.keySet())
			if (word.length() == 5) {
				char c1 = word.charAt(0);
				char c2 = word.charAt(2);
				char c3 = word.charAt(4);
				if (c1 == c2 && c2 == c3) System.out.println(freq(word) + " " + word);
			}*/
		
		/*
		System.out.println("loading");
		String line = FileUtil.loadSBFrom("/Users/doranchak/Downloads/3/all").toString().toUpperCase();
		System.out.println("done loading " + line.length());
		for (String word : map.keySet()) {
			if (word.length() < 3) continue;
			int count = WordFrequencies.occurrencesIn(line, word);
			if (count > 0) System.out.println(word + "	" + word.length() + "	" + WordFrequencies.freq(word) + "	" + count);
		}*/
		
		/*List<WordBean> beans = findAllWordsIn(
				"utitsrawhileotdrshelordsandestinasmoralliesimhertruckingspandithinktheynotgoandmaketheylisttosetomyillhellybeatgoodearlyresmarsitssomuchsornotpromananddatteryouresofarswithasmorefuckingitwolatenilbelockisamethatiredonestobetterncondistoryaddsmuchashistelypasswhereareinagamewashappetsdoneupieationtarentcityofawaitingsidessuretingstandtyrog",
				4, true);
		for (WordBean bean : beans)
			System.out.println(bean);*/

		
		//pivots();
		/*String p = "ILIKEKILLINGPEOPLEBECAUSEITISSOMUCHFUNITIAMOREFUNTHANKILLINGWILDGAMEINTHEFORRESTBECAUSEMANISTHEMOATDANGERTUEANAMALOFALLTOKILLSOMETHINGGIVESMETHEMOATTHRILLINGEXPERENCEITISEVENBETTERTHANGETTINGYOURROCKSOFFWITHAGIRLTHEBESTPARTOFITIATHAEWHENIDIEIWILLBEREBORNINPARADICEANDALLTHEIHAVEKILLEDWILLBECOMEMYSLAVESIWILLNOTGIVEYOUMYNAMEBECAUSEYOUWILLTRY";
		for (String word : wordsWithMinPercentile(p, 6, 10, 70)) {
			System.out.println(word + " " + percentile(word));
		}*/
		//System.out.println(percentile("KILLING"));
		//patternMatch();
		//findAllWordsInFile("/Users/doranchak/Downloads/zkdecrypto-results", 5);
		
		//testFuzzy("TREGRCADRIPONLEYALETHSEVVLAEPEDPATAIECEENIHOTOSIVGAHREGHEREGTOEECFEAAKIEFSNESVLTEEFTDONCGTBRDMSDNHNEEPDFLRDLFREEXLARAELAISEESRTERENELONXAINNARVFNIREORFGNRPOOELBDLIPNFRRTNEREIORBANIEYNEEERTOUNSYVOTCEEINUASNTTSRLELEOFSENURANTATBVLHESVUAIINHTFWLOEDIBVTRPCDBSEETPTROKLHERNEOSWETTRELOOSPNRMTRORHLESDRRGDSAOFHHAPEALSCRTTNISTDREVETREEGSNPSIRNKRFHO");
		//testFuzzy("ERCHANTICTUREOUDANDSOMEONEESTHEDIPLAYORDROWNSTATAARELENATHEHOODISTENTATEWEREANDICESONTHEREISANDRADARDLYPRODIEORESOFCOMPELONLYWASONICNOYWONTERRORTHECOULDINANDSETINACTINGTHECAMBUTTHERBOTHOUGHRESTUNTSOUANDTHEPOINTHEANIDLINETHISCHARDWANTTORRENDEADSBUTADAMCTHASTIATTANANIMPRETINGLOWERPOWERTHINGSCAROWANOLINSCHOSESISAMASSETHISWOWNLOWEDONEOFESSING");
		//testPatternCombinations();
		//patternMatch2();
		//findWords("poadderssensondedtortwascsingemasithislydidthiswilsoheldinutagainereuseonlasanontarofthesthelongboyandeediocetonhsmithnicmultancedfroembarrestinlaruesithasbontastheatfiltoflassiesaidrientheedaneofulaginatetsthatccoupiedfromthethindaystsfrryourfiddleoanddwhiteemranomingarawacrewsshayoopullspaulateytoldinfrienetorerournwisonastacinguidthama", 4);
//		System.out.println(findAllWordsInOrder(
//				"VEHERSINCEDONTATTERSOMEABITWDENENOONTIRSAPATMONEAVEDRRRISCNNERASSHETHERSAIDTDOLCSTHEIRCHILSAWNTHELETIMEOSEDBUTAINANDANDMATENDEASHEWASONETERSESPHTLOINGTHEWASANSIESARRELONWASHIOIEDIWORETREATEISHEDNOTHRDSTOLATEDNESEDOLOIMUCHSALEINOTHEDINHISSNONONTHEHEENAPOWSDIDEAOEMARIDNRDATHITSNOTHESLSTODONSSOTHATICADVTIMORDLETTERIOHWAONWHIERIVEREDAPACGDEUS",
//				3, 100));
		//findZodiacWordsInFiles("/Volumes/doranchak-2/Downloads/AZdecrypt0992c/Results/z340_mr_lowe_patterns/top");
		//headlines();
		//issues();
		//testZodiaclike();
		//findZodiacWordsIn("/Volumes/doranchak-2/Downloads/AZdecrypt0992c/Results/z340_mr_lowe_patterns/all.txt");
//		findZodiacWordsInFiles("/Volumes/Smeggabytes/projects/zodiac/cipher collection/sam blake ciphers/part 3/delme/results/combined2");
		//findWordsWithDoubledLetters();
//		findZWordsThatDecodeToOtherWords();
//		findAllWordsInFile("/Users/doranchak/projects/ciphers/W168/more_enumerations/combined-for-word-search.txt", 5, false, true);
	}
}


