package com.zodiackillerciphers.pivots;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import com.zodiackillerciphers.ciphers.Ciphers;
import com.zodiackillerciphers.ngrams.NGramsBean;
import com.zodiackillerciphers.ngrams.Periods;
import com.zodiackillerciphers.transform.CipherTransformations;

public class PivotPeriodTest {
	
	static boolean DEBUG = false;
	public static void debug(String msg) {
		if (DEBUG) System.out.println(msg);
	}
	
	
	/** shuffle and count the number of repeating bigrams (at period 1)
	 * transpose the shuffle to period 39
	 * count pivots
	 * tally the pivot counts by bigram count
	 */
	public static void shuffleTest() {
		String cipher = Ciphers.cipher[0].cipher;

		int count = 0;
		int[] reps = new int[] {20, 40, 60, 80};
		ShuffleCounts counts = new ShuffleCounts();
		List<Pivot> pivots = null;
		List<PivotPair> pivotPairs = null;
		
		while (true) {
			count++;
			int m = 5;
			for (int n : reps) {
				ShuffleBean bean = shuffleWithRepeatingBigramsFaster(cipher, n);
				if (bean == null) continue;
				if (bean.numRepeats != n) continue;
				
				// additional step: transpose by period m
				String re1 = Periods.rewrite3undo(bean.getShuffle(), m);
				
				// then transpose by period 39
				String re2 = Periods.rewrite3undo(re1, 39);
				
				// count any pivots that form
				pivots = PivotUtils.findPivots(re2, 4);
				pivotPairs = PivotUtils.pairsFrom(pivots);

				int val = 0;
				if (pivots != null) val = pivots.size();
				counts.reportPivotAnyDirection(val, n);

				val = 0;
				if (pivotPairs != null) val = pivotPairs.size();
				counts.reportPivotPair(val, n);
				if (val > 0) {
					for(PivotPair pair : pivotPairs) System.out.println("Pair: " + pair);
					System.out.println("Cipher at period " + m + ": " + re1);
					System.out.println("Cipher at period 39: " + re2);
					System.out.println("Cipher untransposed, " + n + " reps: " + bean.shuffle);
				}
			}
			if (count %10000 == 0 || pivotPairs != null && pivotPairs.size() > 0) {
				System.out.println("Samples: " + count);
				counts.dump();
			}
		}

	}
	
	/**
	 * create a random cipher text that has exactly N repeating bigrams. use the
	 * symbols from the given cipher text.
	 */	
	
	public static String shuffleWithRepeatingBigramsSLOWER(String cipher, int N) {
		// first, shuffle the cipher text
		cipher = CipherTransformations.shuffle(cipher);
		// then loop the following until N repeats are found:
		NGramsBean ng = new NGramsBean(2, cipher);
		StringBuffer sb = new StringBuffer(cipher);
		int expected = 0;
		while (ng.numRepeats() != N) {
			System.out.println("now " + ng.numRepeats());
			StringBuffer copy = new StringBuffer(sb);
			if (ng.numRepeats() < N) {
				// 1) if not enough repeats, add one somewhere randomly
				addRandomRepeat(sb);
				expected = ng.numRepeats() + 1;
			} else {
				// 2) if too many repeats, remove one randomly
				removeRandomRepeat(sb, ng);
				expected = ng.numRepeats() - 1;
			}
			NGramsBean ng2 = new NGramsBean(2, sb.toString());
			if (ng2.numRepeats() != expected) {
				sb = copy;
			} else {
				ng = ng2;
			}
		}
		//System.out.println(sb);
		return sb.toString();
	}
	
	/**
	 * create a random cipher text that has exactly N (or sometimes more) repeating bigrams. use the
	 * symbols from the given cipher text.
	 * 
	 * Currently assumes that N will always be larger than the expected number
	 * of repeats that are generated by random shuffles.
	 * 
	 */
	public static ShuffleBean shuffleWithRepeatingBigramsFaster(String cipher, int N) {
		
		cipher = CipherTransformations.shuffle(cipher);
		NGramsBean ng = new NGramsBean(2, cipher);
		StringBuffer sb = new StringBuffer(cipher);
		int R = ng.numRepeats();
		if (R == N) return new ShuffleBean(cipher, R);
		if (R > N) {
			//throw new RuntimeException("Shuffled cipher already has " + R + " repeats.");
			return null;
		}
		Random rand = new Random();
		Map<Character, List<Integer>> positions = Ciphers.positionMap(cipher);
		while (R < N) {
			debug("LOOP BEGIN " + R + " " + sb);
			StringBuffer sb2 = new StringBuffer(sb);
			
//			NGramsBean ng2 = new NGramsBean(2, sb.toString());
//			if (!NGramsBean.sameCounts(ng, ng2)) {
//				System.out.println("=== ACTUAL:");
//				ng.dump();
//				System.out.println("=== EXPECTED:");
//				ng2.dump();
//				System.exit(-1);
//			}
			
			
			Map<String, Integer> countsCopy = new HashMap<String, Integer>(ng.counts);
			Set<String> repeatsCopy = new HashSet<String>(ng.repeats);
			Set<String> nonrepeatsCopy = new HashSet<String>(ng.nonrepeats);
			// 		pick a random position p1 in [0, cipher.len-1].  This will be the bigram we will try to copy.
			int p1 = rand.nextInt(sb.length()-1);
			//		let c1 = symbol at p1, and c2 = symbol at p1+1
			char c1 = sb.charAt(p1);
			char c2 = sb.charAt(p1+1);
			debug("Selected bigram: " + c1 + c2);
			//		define the bigram at p1 as p1_b1 = {c1,c2}
//			String p1_b1 = ""+c1+c2;
//			System.out.println("selected p1_b1 " + p1_b1 + " (count " + ng.counts.get(p1_b1) + ") at " + p1);
//			System.out.println("c2 " + c2 + " has " + positions.get(c1) + " positions");
			//		pick a random occurrence of c1 at a position p2 where p2 != p1 and p2 does not overlap p1
			List<Integer> positions1 = positions.get(c1);
			// 		we have to abort if there was only one position to pick from, because it is already in p1_b1
			if (positions1.size() < 2) continue;
			// find a random position that contains the first symbol of the bigram we're trying to copy
			int p2 = positions1.get(rand.nextInt(positions1.size()));
//			System.out.println("p1 " + p1 + " p2 " + p2);
			if (Math.abs(p1-p2) < 2) continue; // abort if positions overlap
			if (p2 == sb.length()-1) continue; // abort if symbol at end of cipher, because then can't make bigram
			// we want to replace the symbol at p2+1 with c2, so pick a random c2 from one of its occurrences.  let it be p3.
			List<Integer> positions2 = positions.get(c2);
			// 		we have to abort if there was only one position to pick from, because it is already at p1+1
			if (positions2.size() < 2) continue;
			// pick a random position that contains the 2nd symbol from the bigram we're trying to copy
			int p3 = positions2.get(rand.nextInt(positions2.size()));			
			if (p3 >= p2 && p3 <= p2+1) continue; // abort if positions overlap
			if (p3 >= p1 && p3 <= p1+1) continue; // abort if positions overlap
			if (p3 >= sb.length()-1) continue; // don't pick a position at the end of the cipher
			if (p3 == 0) continue; // don't pick a position at the start of the cipher because then can't make trigram for bigram stat updates (sloppy bandaid)

			// in the bigram we're trying to replace, this is its original 2nd symbol.
			char c3 = sb.charAt(p2+1);
			debug("c1 " + c1 + " c2 " + c2 + " c3 " + c3 + " p1 " + p1 + " p2 " + p2 + " p3 " + p3);
			
			if (c2 == c3) continue; // because it's already a copy of the selected bigram
			
			Map<Character, Integer> map1 = Ciphers.countMap(sb.toString());
			// perform the update to copy the selected bigram
			int newR = R;
			Positions posMap = new Positions();
			debug("update1");
			newR += update(sb, p2, c2, ng, positions, posMap);
			debug("update2");
			newR += update(sb, p3-1, c3, ng, positions, posMap);
			debug("newR " + newR + " R " + R);
			if (DEBUG) posMap.dump();
			debug("positions " + positions);
			
			
//			ng2 = new NGramsBean(2, sb.toString());
//			if (!NGramsBean.sameCounts(ng, ng2) || newR != ng2.numRepeats()) {
//				System.out.println("newR is " + newR + " but num repeats actually " + ng2.numRepeats());
//				System.out.println("=== ACTUAL:");
//				ng.dump();
//				System.out.println("=== EXPECTED:");
//				ng2.dump();
//				System.exit(-1);
//			}
			
			if (newR < R) {
				ng.copy(countsCopy, repeatsCopy, nonrepeatsCopy);
				sb = sb2;
				continue;
			}
			R = newR;
//			System.out.println("R is now " + R);
			
			for (Character c : posMap.added.keySet()) {
				for (Integer pos : posMap.added.get(c)) {
					positions.get(c).add(pos);
				}
			}
			for (Character c : posMap.removed.keySet()) {
				for (Integer pos : posMap.removed.get(c)) {
					positions.get(c).remove(pos);
				}
			}
//			for (int i=0; i<sb.length(); i++) {
//				char key = sb.charAt(i);
//				List<Integer> val = positions.get(key);
//				if (val == null || val.isEmpty()) {
//					System.out.println(positions);
//					System.out.println("ERROR " + i + " " + key + ", empty list of positions.");
//					System.exit(-1);
//				}
//				if (!val.contains(i)) {
//					System.out.println(positions);
//					System.out.println("ERROR " + i + " " + key + ", position not found.");
//					System.exit(-1);
//				}
//			}
//			for (Character key : positions.keySet()) {
//				for (Integer pos2 : positions.get(key)) {
//					if (sb.charAt(pos2) != key) {
//						System.out.println(positions);
//						System.out.println("ERROR: expected " + key + " in sb at " + pos2 + " but found " + sb.charAt(pos2));
//						System.exit(-1);
//					}
//				}
//			}
			
			
//			Map<Character, Integer> map2 = Ciphers.countMap(sb.toString());
//			if (!Ciphers.countMapsEqual(map1, map2)) {
//				System.out.println("ERROR");
//				System.out.println("map1 " + map1);
//				System.out.println("map2 " + map2);
//				System.exit(-1);
//			}
			
			//		there are two affected bigrams p3_b1 and p3_b2 at p3, where p3_b1 covers {p3,p3+1} and p3_b2 covers {p3-1, p3} (unless p3 = 0)
//			String p3_b1 = sb.substring(p3,p3+2);
//			String p3_b2 = null;
//			if (p3 > 0) p3_b2 = sb.substring(p3-1,p3+1);
//			System.out.println("target position p3 " + p3 + " with p3_b1 " + p3_b1
//					+ " (count " + ng.counts.get(p3_b1) + ") and p3_b2 " + p3_b2
//					+ " (count " + ng.counts.get(p3_b2) + ")");
//			if (p2+1>=sb.length()) continue; // out of bounds
			
			// in the bigram we're trying to replace, this is its original 2nd symbol.
//			char c3 = sb.charAt(p2+1);
			
			// there are two more affected bigrams p2_b1 and p2_b2, where p2_b1 covers {p2,p2+1} and p2_b2 covers {p2+1,p2+2} for p2+2 <= length
			// after swap, p2_b2 is equal to p1_b1 
//			String p2_b1 = sb.substring(p2, p2+2);
//			String p2_b2 = null;
//			if (p2+3 < sb.length()) p2_b2 = sb.substring(p2+1,p2+3);
//			System.out.println("target position p2 " + p2 + " with p2_b1 " + p2_b1
//					+ " (count " + ng.counts.get(p2_b1) + ") and p2_b2 " + p2_b2
//					+ " (count " + ng.counts.get(p2_b2) + ")");
			
			//		swap c2 at p3 with symbol c3 at p2+1, and update symbol positions for c2 and c3
//			System.out.println("swapping " + c3 + " at " + (p2+1) + " with " + c2 + " at " + p3);
//			swap(sb, p2+1, p3);
			// c3 moved from p2+1 to p3
//			positions.get(c3).remove(new Integer(p2+1));
//			positions.get(c3).add(new Integer(p3));
			// c2 moved from p3 to p2+1
//			positions.get(c2).remove(new Integer(p3));
//			positions.get(c2).add(new Integer(p2+1));
			//		this will increment p1_b1's count by 1
//			Integer bcount = ng.counts.get(p1_b1);
//			bcount++;
//			ng.counts.put(p1_b1, bcount);
//			System.out.println("p1_b1 " + p1_b1 + " count now " + ng.counts.get(p1_b1));
			//		and R by 1
//			R++;
			//		add a new position for p1_b1 (optional?)
			//		this will decrement p3_b1 and p3_b2's counts by 1
//			bcount = ng.counts.get(p3_b1);
//			if (bcount > 1) R--;
//			bcount--;
//			ng.counts.put(p3_b1,bcount);
//			System.out.println("p3_b1 " + p3_b1 + " count now " + ng.counts.get(p3_b1));
//			if (p3_b2 != null) {
//				bcount = ng.counts.get(p3_b2);
//				if (bcount > 1) R--;
//				bcount--;
//				ng.counts.put(p3_b2,bcount);
//				System.out.println("p3_b2 " + p3_b2 + " count now " + ng.counts.get(p3_b2));
			}
			//		this will decrement p2_b1 and p2_b2's counts by 1
//			bcount = ng.counts.get(p2_b1);
//			if (bcount > 1) R--;
//			bcount--;
//			ng.counts.put(p2_b1,bcount);
//			System.out.println("p2_b1 " + p2_b1 + " count now " + ng.counts.get(p2_b1));
//			if (p2_b2 != null) {
//				bcount = ng.counts.get(p2_b2);
//				if (bcount > 1) R--;
//				bcount--;
//				ng.counts.put(p2_b2,bcount);
////				System.out.println("p2_b2 " + p2_b2 + " count now " + ng.counts.get(p2_b2));
//			}
			
			//		update p3_b1 and p3_b2
//			p3_b1 = "" + c3 + p3_b1.charAt(1); 
//			if (p3_b2 != null) p3_b2 = "" + p3_b2.charAt(0) + c3;
//			System.out.println("p3_b1 is now " + p3_b1 + " count " + ng.counts.get(p3_b1));
//			System.out.println("p3_b2 is now " + p3_b2 + " count " + ng.counts.get(p3_b2));
			//		thus, increment the counts for b2' and b3', and update R is either count is greater than 1
//			bcount = ng.counts.get(p3_b1);
//			if (bcount == null) bcount = 0;
//			bcount++;
//			ng.counts.put(p3_b1, bcount);
//			if (bcount > 1) R++;
//			
//			if (p3_b2 != null) {
//				bcount = ng.counts.get(p3_b2);
//				if (bcount == null) bcount = 0;
//				bcount++;
//				ng.counts.put(p3_b2, bcount);
//				if (bcount > 1) R++;
//			}
//			System.out.println("p3_b1 count is now " + ng.counts.get(p3_b1));
//			System.out.println("p3_b2 count is now " + ng.counts.get(p3_b2));
			
			//		update p2_b2 (p2_b1 is already equal to p1_b1)
//			if (p2_b2 != null) {
//				p2_b2 = "" + c2 + p2_b2.charAt(1);
////				System.out.println("p2_b2 is now " + p2_b2 + " count " + ng.counts.get(p2_b2));
//				//		thus, increment the counts for p2_b2', and update R if count is greater than 1
//				bcount = ng.counts.get(p2_b2);
//				if (bcount == null) bcount = 0;
//				bcount++;
//				ng.counts.put(p2_b2, bcount);
////				System.out.println("p2_b2 count is now " + ng.counts.get(p2_b2));
//				if (bcount > 1) R++;
//			}
			
			//		and add positions for b2' and b3' (optional?)
			
			// TODO: update R properly without relying on ngramsbean
//			NGramsBean ng2 = new NGramsBean(2, sb.toString());
//			if (ng2.numRepeats() < before) {
//				sb = sb2;
//				R = before;
//				continue;
//			}
//			ng = ng2;
//			if (ng.numRepeats() != R) {
//				System.out.println("expected " + R + " but actual was " + ng.numRepeats());
//				ng.dump();
//				throw new RuntimeException("Mismatch!");
//			}
//			
//			R = ng.numRepeats();
//		}
		return new ShuffleBean(sb.toString(), R);
	}
	
	
	public static String shuffleWithRepeatingBigramsFasterCRAP(String cipher, int N) {
		// track counts of symbols.  pairs of symbols where each symbol has count > 1
		// are eligible to use as repeating bigrams.
		
		Random rand = new Random();
		Map<Character, Integer> counts = Ciphers.countMap(cipher);
		
		StringBuffer result = new StringBuffer();
		for (int i=0; i<cipher.length(); i++) result.append(" ");
		
		// symbols to choose from
		Character[] alphabet = counts.keySet().toArray(new Character[0]);
		
		// positions to choose from
//		List<Integer> positions = new ArrayList<Integer>();
//		for (int i=0; i<cipher.length()-1; i++) positions.add(i);
		
		for (int i=0; i<N; i++) {
			int count1 = 0;
			int count2 = 0;
			char c1 = 0;
			char c2 = 0;
			while (count1 < 2 && count2 < 2) {
				c1 = alphabet[rand.nextInt(alphabet.length)]; 
				c2 = alphabet[rand.nextInt(alphabet.length)];
				count1 = counts.get(c1);
				count2 = counts.get(c2);
			}
			// pick 2 random non-overlapping positions for the new bigrams
			int pos1 = 0;
			int pos2 = 0;
			boolean loop = true;
			while (loop) {
				pos1 = rand.nextInt(cipher.length()-1);
				pos2 = rand.nextInt(cipher.length()-1);
				
				// stop conditions:
				// bigrams don't overlap
				// bigram has two empty positions to fit into
				// or, the position has the bigram's 1st symbol followed by a space
				// or, the position has the bigram's 2nd symbol preceded by a space
				// another stop condition: exactly one of the two positions already has the bigram but the other doesn't 
				String sub1 = result.substring(pos1,pos1+2);
				boolean fits1 = sub1.equals("  ");
				fits1 |= sub1.equals(c1 + " ");
				fits1 |= sub1.equals(" " + c2);
				boolean matches1 = sub1.equals(""+c1+c2);

				String sub2 = result.substring(pos2,pos2+2);
				boolean fits2 = sub2.equals("  ");
				fits2 |= sub2.equals(c1 + " ");
				fits2 |= sub2.equals(" " + c2);
				boolean matches2 = sub2.equals(""+c1+c2);

				boolean overlap = Math.abs(pos1-pos2) < 2;
				
				if (!overlap) {
					if (fits1 && matches2 || fits2 || matches1 || fits1 && fits2) {
						loop = false;
					}
				}
				
				//System.out.println("[" + result.substring(pos1,pos1+2) + "][" + result.substring(pos2,pos2+2) + "]");
				if (result.substring(pos1,pos1+2).equals("  ") && result.substring(pos2, pos2+2).equals("  ")) {
					if (Math.abs(pos1-pos2) > 1) loop = false;
				} 
			}
			// place the ngrams
			result.setCharAt(pos1, c1);
			result.setCharAt(pos1+1, c2);
			result.setCharAt(pos2, c1);
			result.setCharAt(pos2+1, c2);
			System.out.println(pos1 + "," + pos2 + "," + c1 + c2 + ": " + result);
			
			// decrement symbol counts by 2
			counts.put(c1, count1-2);
			counts.put(c2, count2-2);
			
		}
		System.out.println(result);
		// now fill out all the spaces with remaining symbols 
		
		return result.toString();
	}
	
	/** add a random repeat to the given string */
	public static void addRandomRepeat(StringBuffer sb) {
		// steps to add a random repeat:
		// 1) pick a bigram at random, let its position = pos1
		int pos1 = new Random().nextInt(sb.length()-1);
		String bigram = sb.substring(pos1, pos1+2);
//		System.out.println("chose bigram " + bigram + " at pos " + pos1);
		// 2) pick another position = pos2.  ensure no overlaps with pos1
		int pos2 = pos1;
		while (pos2 == pos1 || pos2 == pos1-1 || pos2 == pos2+1) {
			pos2 = new Random().nextInt(sb.length()-1);
		}
		// 3) locate bigram's symbols elsewhere in the cipher text
		Map<Character, List<Integer>> map = Ciphers.positionMap(sb.toString());
//		System.out.println(map);
		List<Integer> list1 = map.get(bigram.charAt(0));
		List<Integer> list2 = map.get(bigram.charAt(1));
		// pick positions at random
		int pos3 = list1.get(new Random().nextInt(list1.size()));
		int pos4 = list2.get(new Random().nextInt(list2.size()));
//		System.out.println("picked pos3 " + pos3 + " pos4 " + pos4);
		// 4) swap them into pos2
//		System.out.println("before " + sb);
		swap(sb, pos2, pos3);
		swap(sb, pos2+1, pos4);
//		System.out.println("after " + sb);
		// note: will need to recount because there's no guarantee this didn't break the bigram count
	}
	
	/** remove a random repeat from the given string */
	public static void removeRandomRepeat(StringBuffer sb, NGramsBean bean) {
		// steps to remove a random repeat:
		// 1) pick a repeating bigram at random
		List<String> list = new ArrayList<String>(bean.repeats);
		if (list == null || list.size() == 0) return;
		String ngram = list.get(new Random().nextInt(list.size()));
		// 2) pick one of its positions (pos1) at random
		List<Integer> positions = bean.positions.get(ngram);
		int pos1 = positions.get(new Random().nextInt(positions.size()));
		// 3) pick two more positions at random
		int pos2 = new Random().nextInt(sb.length());
		int pos3 = new Random().nextInt(sb.length());
		// 4) swap symbols from those two positions with pos1 and pos1+1
		swap(sb, pos1, pos2);
		swap(sb, pos1+1, pos3);
	}
	
	/** swap the symbols at the two positions */
	public static void swap(StringBuffer sb, int pos1, int pos2) {
		if (pos1 == pos2) return;
		char tmp = sb.charAt(pos1);
		sb.setCharAt(pos1, sb.charAt(pos2));
		sb.setCharAt(pos2, tmp);
	}
	
	/**
	 * update bigram counts to reflect replacement of the 2nd symbol in the
	 * given ngram with the given character.  also update the change
	 * in symbol positions, and perform the replacement in the original cipher string.
	 * 
	 * returns count changes for the resulting bigrams 
	 * 
	 * @param ngram the ngram in which to replace a symbol
	 * @param pos the start position of the ngram
	 * @param replacement the symbol to use to overwrite the ngram's 2nd position
	 * @param ng ngram bean that tracks counts and positions of bigrams
	 * @param positions map that tracks positions by symbol
	 * @param diffs map tracking which bigrams were removed and added during this update 
	 */
	public static int update(StringBuffer sb, int pos, char replacement, NGramsBean ng,
			Map<Character, List<Integer>> positions, Positions posMap) {
		
		debug("pos " + pos + " replacement " + replacement + " sb " + sb);

		int diff = 0; // net change in number of repeating bigrams

		String bigram1 = sb.substring(pos,pos+2);
		char replaced = bigram1.charAt(1); // this symbol is going to be replaced by the replacement symbol
		String bigram2 = null;
		if (pos+2 < sb.length()) 
			bigram2 = sb.substring(pos+1,pos+3);

//		Integer count1 = ng.counts.get(bigram1);
//		Integer count2 = ng.counts.get(bigram2);
		debug("bigram1 " + bigram1 + " bigram2 " + bigram2);
		diff += ng.remove(bigram1);
		diff += ng.remove(bigram2);

//		if (count1 > 1) updateBean.dec(bigram1); // because we're removing bigram1 and it was a repeat
//		if (count2 != null && count2 > 1) updateBean.dec(bigram2); // because we're removing bigram1 and it was a repeat

//		debug("bigram1 " + bigram1 + " count1 " + count1);
//		debug("bigram2 " + bigram2 + " count2 " + count2);

		/** update counts for the bigrams, because they are removed by the replacement of the symbol */
//		count1--;
//		ng.counts.put(bigram1, count1);
//
//		if (bigram2 != null) {
//			count2--;
//			ng.counts.put(bigram2, count2);
//		}
//
//		debug("updated counts: bigram1 " + bigram1 + " count1 " + count1);
//		debug("updated counts: bigram2 " + bigram2 + " count2 " + count2);

		/** now the bigrams are updated so update their counts */
		bigram1 = "" + bigram1.charAt(0) + replacement;
		if (bigram2 != null)
			bigram2 = "" + replacement + bigram2.charAt(1);
		
		diff += ng.add(bigram1);
		diff += ng.add(bigram2);

		debug("new: bigram1 " + bigram1 + " bigram2 " + bigram2);
		
//		count1 = ng.counts.get(bigram1);
//		count2 = ng.counts.get(bigram2);
//
//		debug("new bigrams: bigram1 " + bigram1 + " count1 " + count1);
//		debug("new bigrams: bigram2 " + bigram2 + " count2 " + count2);
//
//		if (count1 != null && count1 > 0) diff++; // because the new bigram1 is a repeat now 
//		if (count2 != null && count2 > 0) diff++; // because the new bigram2 is a repeat now 
//
//		if (count1 == null) count1 = 0;
//		count1++;
//		ng.counts.put(bigram1, count1);
//
//		if (bigram2 != null) {
//			if (count2 == null) count2 = 0;
//			count2++;
//			ng.counts.put(bigram2, count2);
//		}
//
//		debug("updated counts: new bigrams: bigram1 " + bigram1 + " count1 " + count1);
//		debug("updated counts: new bigrams: bigram2 " + bigram2 + " count2 " + count2);

		// replace the symbol
		sb.setCharAt(pos+1, replacement);

		// we have added the replacement symbol so update its list of positions
		Integer entry = new Integer(pos+1);
		debug("entry: " + entry);
		//debug("positions before for " + replacement + ": " + positions.get(replacement));
		//positions.get(replacement).add(entry);
		posMap.add(replacement, entry);
		//debug("positions after for " + replacement + ": " + positions.get(replacement));

		// we have removed the replaced symbol so update its list of positions
		//debug("positions before for " + replaced + ": " + positions.get(replaced));
		//positions.get(replaced).remove(entry);
		posMap.remove(replaced, entry);
		//debug("positions after for " + replaced + ": " + positions.get(replaced));

		debug("diff " + diff +  " sb after: " + sb);
		
		return diff;
	}	
	
	public static void shuffleTest340() {
		String cipher = Ciphers.cipher[0].cipher;
		
		int count = 0;
		int countPivots = 0;
		int countPivotPairs = 0;
		while (true) {
			count++;
			cipher = CipherTransformations.shuffle(cipher);
			// count any pivots that form
			List<Pivot> pivots = PivotUtils.findPivots(cipher, 4);
			List<PivotPair> pivotPairs = PivotUtils.pairsFrom(pivots);
			if (pivots != null && pivots.size() > 0) {
				countPivots += pivots.size();
				//System.out.println(count + " " + countPivots + " " + countPivotPairs);
			}
			
			if (pivotPairs != null && pivotPairs.size() > 0 || count % 10000 == 0) {
				if (pivotPairs != null) countPivotPairs+=pivotPairs.size();
				System.out.println(count + " " + countPivots + " " + countPivotPairs);
			}
			
		}

	}
	
	/** shuffle a cipher, inject bigrams randomly, and report how often certain bigrams appear */ 
	public static void popularBigramShuffle() {
		String cipher = Ciphers.cipher[0].cipher;
		Map<String, Integer> counts = new HashMap<String, Integer>();
		int N = 40;
		for (int i=0; i<10000; i++) {
			ShuffleBean bean = null;
			while (bean == null || bean.numRepeats != N)
				bean = shuffleWithRepeatingBigramsFaster(cipher, N);
			NGramsBean ng = new NGramsBean(2, bean.shuffle);
			for (String bigram : ng.counts.keySet()) {
				Integer val = counts.get(bigram);
				if (val == null) val = 0;
				val++;
				counts.put(bigram, val);
			}
		}
		System.out.println(counts);
	}
	
	
	public static void main(String[] args) {
		shuffleTest();
		//popularBigramShuffle();
//		for (int i=0; i<100; i++) {
//			String c = shuffleWithRepeatingBigramsFaster(Ciphers.cipher[0].cipher, 30).getShuffle();
//			System.out.println(new NGramsBean(2, c).numRepeats() + " " + c);
//		}
		//shuffleTest340();
		
	}
}
